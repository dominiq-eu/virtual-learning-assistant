{"version":3,"sources":["types.js"],"names":["isNotNull","x","NaN","isType","v","name","isFunction","isObject","isString","isNumber","isBoolean","isArray","Array","throwError","TypeError","e","Pipe","fn","hasFields","fields","obj","filter","hasOwnProperty","f","length","toObject","key","value","setPrototype","setPrototypeOf","proto","Type","typecheck","constructor","val","andThen","is","prototype","constuctor","check","of","derive","toString","StringType","String","ObjectType","Object","NumberType","Number","BooleanType","Boolean","ArrayType","typeMap","getTypecheckedCounterpart","undefined","normalizeDefinition","entries","def","map","typeConstructor","reduce","isValidDataDefinition","typecheckData","keys","typeDef","constructData","data","Data","isValidUnionDefinition","values","d","caseOf","match","type","opts","Union","create","AnyType","NothingType","Maybe","SuccessType","ok","ErrorType","error","Result","EmailRegEx","EmailType","test","module","exports"],"mappings":"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","file":"types.map","sourceRoot":"../src","sourcesContent":["/*\n    type.js\n\n    TODO: Make types immutable\n*/\n\n//\n// -- Helpers --\n//\n\nconst isNotNull = x => x !== undefined && x !== null && x !== NaN\nconst isType = name => v => isNotNull(v) && typeof v === name\nconst isFunction = isType('function')\nconst isObject = isType('object')\nconst isString = isType('string')\nconst isNumber = isType('number')\nconst isBoolean = isType('boolean')\nconst isArray = Array.isArray\n\n// eslint-disable-next-line\nconst throwError = e => {\n    // eslint-disable-next-line\n    throw new TypeError(e)\n}\nconst Pipe = x => ({\n    andThen: fn => Pipe(fn(x)),\n    value: () => x\n})\n\nconst hasFields = (fields, obj) =>\n    isObject(obj) && isArray(fields)\n        ? fields.filter(f => !obj.hasOwnProperty(f)).length === 0\n        : false\nconst toObject = (obj, [key, value]) => {\n    obj[key] = value\n    return obj\n}\nconst setPrototype = proto => obj => {\n    // TODO: Replace with Object.create() because setPrototypeOf can have a\n    //       serious performance impact.\n    if (isNotNull(obj)) {\n        Object.setPrototypeOf(obj, proto)\n    }\n    // obj.prototype = Object.create(proto)\n    return obj\n}\n\n//\n// -- Type Type --\n//\n\n//\n// Find a way of freezing objects to make them immutable. Maybe use:\n// seamless-immutable..?\n//\n// Type :: String -> Fn -> (a -> a)\nconst Type = (name, typecheck, constructor = x => x) => {\n    const obj = {\n        [name]: function(val) {\n            return Pipe(constructor(val))\n                .andThen(\n                    v =>\n                        typecheck(v)\n                            ? v\n                            : throwError(\n                                  `Value '${val}' is not of expected type '${name}'`\n                              )\n                )\n\n                .andThen(setPrototype({ constructor: obj[name] }))\n                .value()\n        }\n    }\n    // Typecheck given value as expression (true/false)\n    obj[name].is = v =>\n        isNotNull(v) && v.prototype && v.prototype.constructor\n            ? v.prototype.constuctor === obj[name]\n            : typecheck(v)\n    // Typecheck given value (return value and throw exception if not)\n    obj[name].check = x =>\n        obj[name].is(x)\n            ? x\n            : throwError(\"Check: Failed: Expect type '\" + name + \"'\")\n    // Create a new type with one exact value\n    obj[name].of = x => Type(name, v => obj[name].is(v) && v === x, () => x)\n    // Create a new sub type of current type.\n    obj[name].derive = f => Type(name, obj[name].is, v => constructor(f(v)))\n    obj[name].toString = () => name + '(x)'\n    // obj[name].inspect = () => name + '(x)'\n    return obj[name]\n}\n\n//\n// -- JS Type Replacements --\n//\n\nconst StringType = Type('String', isString, String)\nconst ObjectType = Type('Object', isObject, Object)\nconst NumberType = Type('Number', isNumber, Number)\nconst BooleanType = Type('Boolean', isBoolean, Boolean)\nconst ArrayType = Type('Boolean', Array.isArray, Array)\n\nconst typeMap = {}\ntypeMap[String] = StringType\ntypeMap[Object] = ObjectType\ntypeMap[Number] = NumberType\ntypeMap[Boolean] = BooleanType\ntypeMap[Array] = ArrayType\n\n// const replaceWithTypecheckedVersion = constructor =>\nconst getTypecheckedCounterpart = constructor =>\n    typeMap[constructor] !== undefined ? typeMap[constructor] : constructor\n\n//\n// -- Data Type --\n//\n\nconst normalizeDefinition = def =>\n    // Replace default type constructor (eg. String) with our typechecked\n    // counterparts.\n    Object.entries(def)\n        .map(([name, typeConstructor]) => [\n            name,\n            isObject(typeConstructor)\n                ? normalizeDefinition(typeConstructor)\n                : getTypecheckedCounterpart(typeConstructor)\n        ])\n        .reduce(toObject, {})\n\n// Every object is a valid definition\nconst isValidDataDefinition = isObject\n\n// Structural typecheck\nconst typecheckData = typeDef => val =>\n    isObject(val) &&\n    hasFields(Object.keys(typeDef), val) &&\n    // Filter out all keys that pass the typecheck\n    Object.entries(typeDef).filter(([key, type]) => !type.is(val[key]))\n        .length === 0\n\nconst constructData = typeDef => data =>\n    Object.entries(typeDef)\n        .map(([key, typeConstructor]) => [key, typeConstructor(data[key])])\n        .reduce(toObject, {})\n\n//\n//\n//\n// Data :: (String, Object) => Constructor\nconst Data = (name, typeDef) =>\n    // 1. Check if we have a valid data type definition\n    // 2. Create a constructor out of the type definition.\n    isValidDataDefinition(typeDef)\n        ? Pipe(normalizeDefinition(typeDef))\n              .andThen(def =>\n                  Type(name, typecheckData(def), constructData(def))\n              )\n              .value()\n        : throwError(\n              'Data: Type definition must consist only of functions and objects containing functions'\n          )\n\n//\n// -- Union Type --\n//\n\nconst isValidUnionDefinition = def =>\n    // Filter out all functions. Everything that's left is unwanted.\n    Object.values(def).filter(d => !isFunction(d)).length === 0\n\nconst caseOf = (typeDef, val) => opts => {\n    const match = Object.entries(typeDef)\n        .filter(([name, type]) => type.is(val))\n        .map(([name, type]) => name)\n    const name = match[0]\n    const fn = opts[name]\n    return !!fn ? fn(val) : throwError(`${name} is not in the object!`)\n}\n\n// Union ::\nconst Union = (name, typeDef) =>\n    // Check if typedef just containing functions\n    isValidUnionDefinition(typeDef)\n        ? Pipe(normalizeDefinition(typeDef))\n              .andThen(def =>\n                  Object.entries(def)\n                      .map(([name, type]) => [name, Type(name, type.is, type)])\n                      .reduce(\n                          toObject,\n                          Object.create({\n                              toString: () => name,\n                              is: x =>\n                                  Object.values(def).filter(type => type.is(x))\n                                      .length > 0,\n                              check(x) {\n                                  return this.is(x)\n                                      ? x\n                                      : throwError(\n                                            \"Check: Failed: Expect type '\" +\n                                                name +\n                                                \"'\"\n                                        )\n                              },\n                              case: (v, opts) => caseOf(def, v)(opts)\n                          })\n                      )\n              )\n              //   .andThen(Object.freeze)\n              .value()\n        : // wrong type definition\n          throwError('Union: Type definition must consist only of functions')\n\n//\n// -- Maybe Type --\n//\n\nconst AnyType = Type('Any', v => isNotNull(v))\n// eslint-disable-next-line\nconst NothingType = Type('Nothing', v => !isNotNull(v), x => undefined)\n\nconst Maybe = Union('Maybe', {\n    // Just: Data('Just', { value: AnyType }),\n    // Nothing: Data('Nothing', { value: NothingType })\n    Just: AnyType,\n    Nothing: NothingType\n})\n\n//\n// -- Result Type --\n//\n\nconst SuccessType = Type(\n    'Ok',\n    v => isObject(v) && v.ok === true && AnyType.is(v.value),\n    v => ({ ok: true, value: AnyType(v) })\n)\nconst ErrorType = Type(\n    'Error',\n    v => isObject(v) && v.ok === false && StringType.is(v.error),\n    v => ({ ok: false, error: StringType(v) })\n)\nconst Result = Union('Result', {\n    Ok: SuccessType,\n    Err: ErrorType\n})\n\n//\n// -- Email Type --\n//\nconst EmailRegEx = /^(([^<>()\\[\\]\\\\.,;:\\s@\"]+(\\.[^<>()\\[\\]\\\\.,;:\\s@\"]+)*)|(\".+\"))@((\\[[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\])|(([a-zA-Z\\-0-9]+\\.)+[a-zA-Z]{2,}))$/\nconst EmailType = Type(\n    'Email', // Name\n    x => StringType.is(x) && EmailRegEx.test(x), // Validator\n    StringType // Constructor\n)\n\n//\nmodule.exports = {\n    // Tools provided to build types\n    Type,\n    Data, // Type\n    Union,\n\n    // ADTs\n    Maybe,\n    Result,\n\n    // Types\n    StringType,\n    ObjectType,\n    NumberType,\n    BooleanType,\n    ArrayType,\n    AnyType,\n    NothingType,\n\n    // Specific Sub Types\n    EmailType\n\n    // Success: SuccessType,\n    // Error: ErrorType\n}\n\n// TODO: Need to write tests for the types!\n\n/*\n\nconst { Maybe } = require(\"./types.js\")\n\nconst j = Maybe.Just(\"Hey Ho!\")\nconst n = Maybe.Nothing()\n\nMaybe.case(j, {\n    Just: (v) => console.log(\"Just: \", v),\n    Nothing: (v) => console.log(\"Nothing: \", v)\n})\nMaybe.case(n, {\n    Just: (v) => console.log(\"Just: \", v),\n    Nothing: (v) => console.log(\"Nothing: \", v)\n})\n\n\nconst { Result } = require(\"./type.js\")\n\nconst a = Result.Ok({ Some: \"Data\" })\na\nconst e = Result.Err(\"Oje Oje..\")\ne\n\n\n\nconst Type = require(\"./types.js\")\n\nconst Coord = Type.Type('Coord', Type.Number.is)\nCoord.toString()\nCoord.name\nconst c = Coord(23)\nc\nCoord.is(c)\n\nconst Point = Type.Data(\"Point\", { x: Coord, y: Coord, z: Number })\nPoint.toString()\nPoint.name\nconst p = Point({ x: 1, y: 1, z: 1 })\np\nPoint.is(p)\n\nconst Space = Type.Union(\"Space\", {\n    Planet: Point,\n    SolarSystem: Point\n})\nSpace.toString()\nconst s = Space.Planet(p)\ns\ns.toString()\nSpace.is(s)\n\nSpace.case(s, {\n    Planet: (s) => \"It's a planet\",\n    SolarSystem: (s) => \"It's a solar system\"\n})\n\n// s.case({\n//     Planet: (s) => console.log(\"It's a planet\"),\n//     SolarSystem: (s) => console.log(\"It's a solar system\")\n// })\n\n\n*/\n"]}